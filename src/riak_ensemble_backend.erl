%% -------------------------------------------------------------------
%%
%% Copyright (c) 2013 Basho Technologies, Inc.  All Rights Reserved.
%%
%% This file is provided to you under the Apache License,
%% Version 2.0 (the "License"); you may not use this file
%% except in compliance with the License.  You may obtain
%% a copy of the License at
%%
%%   http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing,
%% software distributed under the License is distributed on an
%% "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
%% KIND, either express or implied.  See the License for the
%% specific language governing permissions and limitations
%% under the License.
%%
%% -------------------------------------------------------------------

%% @doc
%% This module defines riak_ensemble_backend behavior used to implement
%% custom peer behavior.

-module(riak_ensemble_backend).

-include_lib("riak_ensemble_types.hrl").

%% API
-export([start/4,
         get_obj/3,
         set_obj/4,
         latest_obj/3,
         reply/2,
         pong/1,
         sync_complete/1,
         sync_failed/1]).

%%===================================================================

-type state() :: any().
-type obj()   :: any().
-type key()   :: any().
-type value() :: any().
-type from()  :: {{_,_}, peer_id()} |
                 {riak_ensemble_msg:msg_from(), peer_id()}.

-export_type([from/0]).

%%===================================================================

%% Initialization callback that returns initial module state.
-callback init(ensemble_id(), peer_id(), [any()]) -> state().

%% Create a new opaque key/value object using whatever representation
%% the defining module desires.
-callback new_obj(epoch(), seq(), key(), value()) -> obj().

%% Accessors to retrieve epoch/seq/key/value from an opaque object.
-callback obj_epoch(obj()) -> epoch().
-callback obj_seq  (obj()) -> seq().
-callback obj_key  (obj()) -> term().
-callback obj_value(obj()) -> term().

%% Setters for epoch/seq/value for opaque objects.
-callback set_obj_epoch(epoch(), obj()) -> obj().
-callback set_obj_seq  (seq(),   obj()) -> obj().
-callback set_obj_value(term(),  obj()) -> obj().

%% Callback for get operations. Responsible for sending a reply to the
%% waiting `from' process using {@link reply/2}.
-callback get(key(), from(), state()) -> state().

%% Callback for put operations. Responsible for sending a reply to
%% the waiting `from' process using {@link reply/2}.
-callback put(key(), obj(), from(), state()) -> state().

%% Callback for sync_request sent from a remote peer that wants to sync
%% with this peer. Responsible for sending a reply to the waiting `from'
%% peer using {@link reply/2}.
-callback sync_request(from(), state()) -> state().

%% Callback that should do whatever is necessary to bring this peer
%% up-to-date. Passed in a list of replies generated by `sync_request'
%% from a quorum of peers from each view. This callback can either
%% directly make the peer current and return `ok', or initiate some
%% longer lived background process and return `async', followed by
%% calling {@link sync_complete/1} or {@link sync_failed/1} when
%% finished/failed.
-callback sync([{peer_id(), any()}], state()) -> {ok, state()}       |
                                                 {async, state()}    |
                                                 {{error,_}, state()}.

%% Callback for periodic leader tick. This function is called periodically
%% by an elected leader. Can be used to implement custom housekeeping.
-callback tick(epoch(), seq(), peer_id(), views(), state()) -> state().

%% Callback used to ensure that the backend is still healthy. If `async'
%% is returned, backend should eventually call {@link pong/1}.
-callback ping(pid(), state()) -> {ok|async|failed, state()}.

%%===================================================================

start(Mod, Ensemble, Id, Args) ->
    Mod:init(Ensemble, Id, Args).

get_obj(Mod, X, Obj) ->
    case X of
        epoch ->
            Mod:obj_epoch(Obj);
        seq ->
            Mod:obj_seq(Obj);
        key ->
            Mod:obj_key(Obj);
        value ->
            Mod:obj_value(Obj)
    end.

set_obj(Mod, X, Val, Obj) ->
    case X of
        epoch ->
            Mod:set_obj_epoch(Val, Obj);
        seq ->
            Mod:set_obj_seq(Val, Obj);
        value ->
            Mod:set_obj_value(Val, Obj)
    end.

latest_obj(Mod, ObjA, ObjB) ->
    A = {Mod:obj_epoch(ObjA), Mod:obj_seq(ObjA)},
    B = {Mod:obj_epoch(ObjB), Mod:obj_seq(ObjB)},
    case B > A of
        true  -> ObjB;
        false -> ObjA
    end.

-spec reply(from(), any()) -> ok.
reply({{To, Tag}, _Id}, Reply) ->
    catch To ! {Tag, Reply},
    ok;
reply({From, Id}, Reply) ->
    riak_ensemble_msg:reply(From, Id, Reply),
    ok.

-spec sync_complete(pid()) -> ok.
sync_complete(Pid) ->
    riak_ensemble_peer:sync_complete(Pid).

-spec sync_failed(pid()) -> ok.
sync_failed(Pid) ->
    riak_ensemble_peer:sync_failed(Pid).

-spec pong(pid()) -> ok.
pong(From) ->
    riak_ensemble_peer:backend_pong(From).
